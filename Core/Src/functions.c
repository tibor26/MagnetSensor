/*
ï¿½ Namawell 
 * RFID demo project

 * This file contains all the functions that are not generated by the MCC
*/
#include "stm32g0xx_it.h"
#include "functions.h"

//---------------------------------------------------------------------------------------
    uint8_t sensorData[16];
    uint8_t dummyBuffer[16];  // To send dummy bytes for reading
    
// Redirected the systick function here.
// So that there is a minimum change to the auto-generated stm32g0xx.it.c file.
void HAL_IncTick(void)
    {
      uwTick += (uint32_t)uwTickFreq;
      pgv->timerFlags |= ftimer_01ms;
// For delay
      if (pgv->delayTimeCounter > 0)      //The delay function must be inside the ISR
      {
          pgv->delayTimeCounter--;
      }
    }

void shortDelay(uint16_t time)     // delay a number of Fosc cycles. Not accurate
{
    while (time > 0)
    {
        time--;
    }
}

void timedAppTasks(void)
{

    if (pgv->timerFlags & ftimer_01ms)
    {
        timedEvents_01ms();
    }
    
    if (pgv->timerFlags & ftimer_05ms)
    {
        timedEvents_05ms();
    }
    if (pgv->timerFlags & ftimer_10ms)
    {
        timedEvents_10ms();     //To read sensor data and send them to UART2
    }
    
    if (pgv->timerFlags & ftimer_50ms)
    {
        timedEvents_50ms();     //To read sensor data and send them to UART2
    }    
    
    if (pgv->timerFlags & ftimer_100ms)
    {
        timedEvents_100ms();     //To read tag data and send them to UART2
    }

    if (pgv->UART2Flags & fUART2_RxMsgReady)
    {
        
        UART2_RxMessageProcess();
    }
}


void timedEvents_01ms(void)
{
    pgv->timerFlags &= ~ftimer_01ms;

    //--- Timed events
    pgv->timerCnt_05ms++;
    if (pgv->timerCnt_05ms == 5)
    {
        pgv->timerCnt_05ms = 0;
        pgv->timerFlags |= ftimer_05ms;
    }
    
    pgv->timerCnt_10ms++;
    if (pgv->timerCnt_10ms == 10)
    {
        pgv->timerCnt_10ms = 0;
        pgv->timerFlags |= ftimer_10ms;
    }
    
    pgv->timerCnt_50ms++;
    if (pgv->timerCnt_50ms == 50)
    {
        pgv->timerCnt_50ms = 0;
        pgv->timerFlags |= ftimer_50ms;
    }
    
    pgv->timerCnt_100ms++;
    if (pgv->timerCnt_100ms == 100)
    {
        pgv->timerCnt_100ms = 0;
        pgv->timerFlags |= ftimer_100ms;
    }  

}

void timedEvents_05ms(void)
{
    pgv->timerFlags &= ~ftimer_05ms;
    // LATDbits.LATD10 ^= 1;
} 

void timedEvents_10ms(void)
{
    pgv->timerFlags &= ~ftimer_10ms;

}

void timedEvents_50ms(void)
{

    pgv->timerFlags &= ~ftimer_50ms;


}

void timedEvents_100ms(void)
{
	static uint8_t tcnt = 0;

    pgv->timerFlags &= ~ftimer_100ms;

    if (tcnt++ > 4)
    {
    	tcnt = 0;
    	HAL_GPIO_TogglePin(USERLED_GPIO_Port, USERLED_Pin);
    }

	pgv->txBuffer[1] = 0xFF;		//Not valid data

    if(pgv->mSensorFlags & fmsensor_ready)
    {
		if (mSensor_Read() == HAL_OK)	//To read the x, y, z magnetic fields

		{
			pgv->txBuffer[1] = SENSOR_ID;
		}
    } else
    {
    	mSensor_Init();	//Repeat trying
    }

	pgv->txBuffer[0] = MSG_HEADER_OUT;

	pgv->txBuffer[2] = pgv->magnetData[0];
	pgv->txBuffer[3] = pgv->magnetData[1];
	pgv->txBuffer[4] = pgv->magnetData[2];
	pgv->txBuffer[5] = pgv->magnetData[3];
	pgv->txBuffer[6] = pgv->magnetData[4];
	pgv->txBuffer[7] = pgv->magnetData[5];

	HAL_UART_Transmit_IT(&huart2, pgv->txBuffer, 8);
}


void myDelay(uint16_t delayTime)    // delay Time in ms. using timer1
{
    pgv->delayTimeCounter = delayTime;
    while (pgv->delayTimeCounter);   //delay time is counted in the TimeoutCallback 
}


void HAL_UART_TxCpltCallback(UART_HandleTypeDef *husart)
{
    // Transmission complete, handle the event here
    // Example: Toggle an LED or send a message
}

void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{ 


	pgv->rxBufferIndex++;
    if (pgv->rxBufferIndex >= pgv->bytesToRx)
    {
    	pgv->rxBufferIndex = 0;
        pgv->UART2Flags |= fUART2_RxMsgReady;
    }
	HAL_UART_Receive_IT(&huart2, &pgv->rxBuffer[pgv->rxBufferIndex], 1);
} 

void UART2_RxMessageProcess(void)
{
    pgv->UART2Flags &= ~fUART2_RxMsgReady;

    if ((pgv->rxBuffer[0] == 0x55) && (pgv->rxBuffer[1] == 0xAA))
    {
    	pgv->txBuffer[0] = MSG_HEADER_OUT;
    	pgv->txBuffer[1] = 0x01;			// message received
        pgv->txBuffer[2] = 'O';
        pgv->txBuffer[3] = 'K';

        HAL_UART_Transmit_IT(&huart2, pgv->txBuffer, 8);
    }
}

void App_Init(void)	// To initialize some parameters and initiate uart receiving
{
	for (uint8_t i = 0; i<6; i++)
	{
		pgv->magnetData[i] = 0x31+i;
	}

// initiate UART receiving
	pgv->rxBufferIndex = 0;
	pgv->bytesToRx = 2; 	//To receive 2 bytes
	HAL_UART_Receive_IT(&huart2, &pgv->rxBuffer[pgv->rxBufferIndex], 1);

// initialize the magnetic sensor
	mSensor_Init();

}

HAL_StatusTypeDef mSensor_Init(void)
{
	mSensor_Write_Register(0x20, 0x70);  // Set ODR to 10Hz, enable X, Y, Z
	mSensor_Write_Register(0x21, GAUSS_SCALE_16);  // gauss scale
	mSensor_Write_Register(0x22, 0x00);  // Continuous-conversion mode
	mSensor_Write_Register(0x23, 0x0C);  // High-performance mode for Z-axis

	myDelay(10);		//Delay 10ms;

	if (mSensor_Read_Register(0x0F) == HAL_OK)
	{
		if (pgv->spiRxBuffer[0] == SENSOR_ID)
		{
			pgv->mSensorFlags |= fmsensor_ready;
			return HAL_OK;
		} else
		{
			pgv->mSensorFlags &= ~fmsensor_ready;
			return HAL_ERROR;		// Failed with identification
		}
	} else
	{
		return HAL_ERROR;		// Failed communicates with the sensor
	}

}

HAL_StatusTypeDef mSensor_Read(void)	// To read the magnetic fields out, x, y, z total 6 bytes.
{
	uint8_t result;
	// 6 bytes starting from 0x28, continuous read

	if (mSensor_Read_Block(0x28, pgv->spiRxBuffer, 6) == HAL_OK)
	{
		result = HAL_OK;
	} else
	{
		result = HAL_ERROR;
	}


	return result;
}

HAL_StatusTypeDef mSensor_Read_Register(uint8_t address)	//Return the register value
{
	uint8_t result;
	// read one register value
    uint8_t txData[1];  // Transmit buffer: only the register address
    txData[0] = address | 0x80;  // Register address with MSB set to 1 for read, one register value

	HAL_GPIO_WritePin(SPI2_NSS_GPIO_Port, SPI2_NSS_Pin, GPIO_PIN_RESET);
	shortDelay(50);		//Delay a number of clock cycles
    // Transmit the register address
    if (HAL_SPI_Transmit(&hspi2, txData, 1, HAL_MAX_DELAY) != HAL_OK)
    {
    	result = HAL_ERROR;
    }

    // Receive the data from the sensor
    if (HAL_SPI_Receive(&hspi2, pgv->spiRxBuffer, 1, HAL_MAX_DELAY) == HAL_OK)
    {
    	result = HAL_OK;
    } else
    {
    	result = HAL_ERROR;
    }

	HAL_GPIO_WritePin(SPI2_NSS_GPIO_Port, SPI2_NSS_Pin, GPIO_PIN_SET);
	shortDelay(50);

    return result;

}


HAL_StatusTypeDef mSensor_Read_Block(uint8_t address, uint8_t *pdata, uint8_t length)	//To read a block of data out of the sensor
{
	uint8_t result, i;
	// read multiple register values continuously
    uint8_t txData[1];  // Transmit buffer: only the register address
    txData[0] = address | 0xC0;  // Register address with D7 set to 1 for read, D6 set to 1 for auto address increment

	HAL_GPIO_WritePin(SPI2_NSS_GPIO_Port, SPI2_NSS_Pin, GPIO_PIN_RESET);
	shortDelay(50);		//Delay a number of clock cycles
    // Transmit the register address
    if (HAL_SPI_Transmit(&hspi2, txData, 1, HAL_MAX_DELAY) != HAL_OK)
    {
    	result = HAL_ERROR;
    }

    // Receive the data from the sensor
    if (HAL_SPI_Receive(&hspi2, pdata, length, HAL_MAX_DELAY) == HAL_OK)
    {
    	for (i=0; i<6; i++)
    	{
    		pgv->magnetData[i] = pgv->spiRxBuffer[i];
    	}
    	result = HAL_OK;
    } else
    {
    	result = HAL_ERROR;
    }
	HAL_GPIO_WritePin(SPI2_NSS_GPIO_Port, SPI2_NSS_Pin, GPIO_PIN_SET);
	shortDelay(50);		//Delay a number of clock cycles

    return result;
}

HAL_StatusTypeDef mSensor_Write_Register(uint8_t address, uint8_t data)		// To write one byte to the register
{
	uint8_t result;
	uint8_t txData[2];  // Transmit buffer: register address + data
	txData[0] = address;  // Register address
	txData[1] = data;     // Data to be written

	HAL_GPIO_WritePin(SPI2_NSS_GPIO_Port, SPI2_NSS_Pin, GPIO_PIN_RESET);
	shortDelay(50);		//Delay a number of clock cycles

	// Transmit the register address and data
	result = HAL_SPI_Transmit(&hspi2, txData, 2, HAL_MAX_DELAY);

	HAL_GPIO_WritePin(SPI2_NSS_GPIO_Port, SPI2_NSS_Pin, GPIO_PIN_SET);
	shortDelay(50);		//Delay a number of clock cycles
	return result;
}


